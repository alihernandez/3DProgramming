<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@v0.168.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@v0.168.0/examples/jsm/"
        }
      }
    </script>
    <title>Three.JS</title>
  </head>
  <body></body>

  <script type="module">
    import * as THREE from "three";
    // let scene, camera, renderer, cube;
    // let scene, camera, renderer, torus;

    let scene, camera, renderer, shape;
    let ADD = 0.08;

let createGeometry = function() {
    let geometry = new THREE.BufferGeometry();

    // Define the vertices using a Float32Array
    const vertices = new Float32Array([
        3, 0, -3,  // Vertex 0 x axis
        -3, 1, 0,  // Vertex 1 y axis
        0, -1, 3,  // Vertex 2 
        -4, 0, 0  // Vertex 3
    ]);

    // Define the faces (indices that define which vertices make up each triangle)
    const indices = [
        0, 1, 2,  // Face 1
        0, 2, 3   // Face 2
    ];

    // Assign the vertex and index data to the geometry
    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    geometry.setIndex(indices);

    // Define the material
    let material = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        side: THREE.DoubleSide,
        wireframe: false
    });

    // Create the mesh and add it to the scene
    shape = new THREE.Mesh(geometry, material);
    scene.add(shape);
//     const axesHelper = new THREE.AxesHelper( 15 );
// scene.add( axesHelper );
};
    
    
    // set up the environment - 
    // initiallize scene, camera, objects and renderer
    let init = function() {
        // create the scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);
        
        // create an locate the camera
        camera = new THREE.PerspectiveCamera(75, 
                        window.innerWidth / window.innerHeight, 
                        1, 1000);
        // camera.position.z = 20;
        // camera.position.x = 5;
        // camera.position.y = 2;
        camera.position.set(0, 0, 20);
        
        createGeometry();
        
        // create the renderer   
        renderer = new THREE.WebGLRenderer();   
        renderer.setSize(window.innerWidth, window.innerHeight);
        
        document.body.appendChild(renderer.domElement);
        
    };
   
    
    let reverseX1 = false;  // Flag to control x-direction
    let reverseX3 = false;  // Flag to control x-direction
let reverseX = false;  // Flag to control z-direction

let mainLoop = function() {

    // Access the position attribute
    let position = shape.geometry.attributes.position;
    shape.position.y = -1;

    for (let i = 0; i < position.count; i++) {
    let x = position.getX(i);
    let y = position.getY(i);
    let z = position.getZ(i);


// Apply movement only to vertex 3 (index 3)
if (i === 3 ) {
        if (!reverseX3) {
            position.setY(i, y - ADD);  // Move down (decrease y)
            
            console.log("Moving down, y:", y);
        } else {
            position.setY(i, y + ADD);
            // shape.rotation.z += -0.01;  // Move up (increase y)
            console.log("Moving up, y:", y);
        }

        // Check for boundary limits and reverse direction
        if (y < -1) {
            reverseX3 = true;  // Start moving up (reverse direction)
            console.log("VERTEX3 UP: reverseX3 is now", reverseX3);
        } else if (y > 1) {
            reverseX3 = false; // Start moving down (reverse direction)
            console.log("VERTEX3 DOWN: reverseX3 is now", reverseX3);
        }
    }


    // Shared flag to control the direction for both vertices
    if (i === 1 ) {
    if (!reverseX) {
        position.setY(i, y - ADD);  // Move down (decrease y)
        console.log(`Moving down, vertex ${i}, y:`, y);
    } else {
        position.setY(i, y + ADD);  // Move up (increase y)
        console.log(`Moving up, vertex ${i}, y:`, y);
    }

    // Check for boundary limits and reverse direction
    if (y <= -1) {
        reverseX = true;  // Start moving up (reverse direction)
        console.log(`VERTEX ${i} UP: reverseX is now`, reverseX);
    } else if (y >= 1) {
        reverseX = false;  // Start moving down (reverse direction)
        console.log(`VERTEX ${i} DOWN: reverseX is now`, reverseX);
    }
}

// Debug logs
console.log("y-axis: ", y);
console.log("x-axis: ", x);
    }

    // Mark the position attribute for update
    position.needsUpdate = true;

    // Render the scene and request the next frame
    renderer.render(scene, camera);
    requestAnimationFrame(mainLoop);
};

    ///////////////////////////////////////////////
    init();
    mainLoop();
  </script>
</html>





